#!/usr/bin/env ruby
require "rubygems"
require "protobuf"
require "protobuf/message"
require "protobuf/descriptors"
require "protobuf/descriptors/google/protobuf/compiler/plugin.pb"
require "erb"

def prefix(file)
  file.package ? 
    file.package.split(".").map{ |seg| seg.capitalize + "_" }.join("") :
    ""
end

def type_label(field)
  "string"
end

def type(field)
  "String"
end

def caps(s)
  s.capitalize
end

class Indexes < ::Protobuf::Enum
  define :NONE, 0
  define :PRIMARY, 1
  define :UNIQUE, 2
  define :FOREIGN, 3
end

class Index < ::Protobuf::Message
  required Indexes, :type, 1
  repeated :int32, :keys, 2
end

Google::Protobuf::FieldOptions.optional Index, :index, 50001
bindings = {}

request = Google::Protobuf::Compiler::CodeGeneratorRequest.decode(STDIN.read)
template = ERB.new(DATA.read)
content = template.result(binding)
file = Google::Protobuf::Compiler::CodeGeneratorResponse::File.new
file.name = "jane.pb.swift"
file.content = content
response = Google::Protobuf::Compiler::CodeGeneratorResponse.new
response.file << file
print response.encode

__END__
import Promises
import Jane
import Swinject
import SwinjectAutoregistration
import Foundation
<%
desired = request.file_to_generate.to_set
request.proto_file.select{|f| desired.include?(f.name) }.each do |file|
  bindings[file] ||= []
  file.message_type.each do |message| 
    klass = prefix(file)+message.name
    bindings[file] << klass
    primary_key = nil
    unique_keys = []
    foreign_keys = {}
    message.field.each do |field|
      index_type = field.options && field.options.index && field.options.index.type
      case index_type
      when Indexes::PRIMARY; primary_key = field
      when Indexes::UNIQUE; unique_keys << field
      end
    end
    %>  
    
    class <%=klass%>Repository: Repository<<%=klass%>> {
      <% if primary_key %>
        // findOne
        func findBy<%=caps(primary_key.name)%>(_ key: <%=type(primary_key) %>) -> Promise<<%=klass%>?> {
          return self._findByPKRaw(BytesWrapper("<%=klass%>", "<%=caps(primary_key.name)%>", <%=type_label(primary_key)%>: key))
        }
        // findAllArray
        func findBy<%=caps(primary_key.name)%>s(_ keys: [<%=type(primary_key) %>]) -> Promise<[<%=klass%>?]> {
          return all(keys.map{ findBy<%=caps(primary_key.name)%>($0)})
        }
        
        // findAllVariadic
        func findBy<%=caps(primary_key.name)%>s(_ keys: <%=type(primary_key) %>...) -> Promise<[<%=klass%>?]> {
          return all(keys.map{ findBy<%=caps(primary_key.name)%>($0)})
        }
        
        func _findByPKRaw(_ data: BytesWrapper) -> Promise<<%=klass%>?> {
          return self.storage.get(key: data).then { (maybeBytes: BytesWrapper?) -> <%=klass%>? in
            if let bytes = maybeBytes {
              return try! <%=klass%>(serializedData: bytes.toData())
            } else {
              return nil
            }
          }
        }
      <% end %>
      
      <% unique_keys.each do |field| %>
        func findBy<%=caps(field.name)%>(_ key: <%=type(field) %>) -> Promise<<%=klass%>?> {
          return self.storage.get(key: BytesWrapper("<%=klass%>", "<%=caps(field.name)%>", <%=type_label(field)%>: key)).then { (maybeBytes: BytesWrapper?) -> Promise<<%=klass%>?> in
            if let bytes = maybeBytes {
              return self._findByPKRaw(bytes)
            } else {
              return Promise<<%=klass%>?>(nil)
            }
          }
        }
        // findAllArray
        func findBy<%=caps(field.name)%>s(_ keys: [<%=type(field) %>]) -> Promise<[<%=klass%>?]> {
          return all(keys.map{ findBy<%=caps(field.name)%>($0)})
        }
        
        // findAllVariadic
        func findBy<%=caps(field.name)%>s(_ keys: <%=type(field) %>...) -> Promise<[<%=klass%>?]> {
          return all(keys.map{ findBy<%=caps(field.name)%>($0)})
        }
      <% end %>
    }
    
    extension <%=klass%>: StorageMappable {
      <% if primary_key %>
      public static func with(
          _ populator: (inout <%=klass%>) throws -> ()
        ) rethrows -> <%=klass%> {
          var message = <%=klass%>()
          message.<%=primary_key.name%> = UUID().uuidString
          try populator(&message)
          return message
        }
      <% end %>
        
      func toValue() -> BytesWrapper {
        return BytesWrapper(data: try! serializedData())
      } 
      func primaryIndex() -> BytesWrapper? {
        <% if primary_key %>
          return BytesWrapper("<%=klass%>", "<%=caps(primary_key.name)%>", <%=type_label(primary_key) %>: self.<%=primary_key.name%>)
        <% else %>
          return nil
        <% end %>
      }
      func secondaryIndexes() -> [Index: BytesWrapper] {
        var out: [Index: BytesWrapper] = [:]
        <% unique_keys.each do |field| %>
          out[Index(name: BytesWrapper("<%=klass%>", "<%=caps(field.name)%>", <%=type_label(field)%>: self.<%=field.name%>), unique: true)] = self.primaryIndex()
        <% end %>
        return out
      }
      
      static func repository() -> <%=klass%>Repository.Type {
        return <%=klass%>Repository.self
      }
    }
  <% end %>
<% end %>

<% bindings.each do |file, klasses|%>
  class <%=prefix(file)%>Binder {
    static func bind(_ container: Container) {
      <% klasses.each do |klass| %>
        container.autoregister(<%=klass%>Repository.self, initializer: <%=klass%>Repository.init)
      <% end %>
    }
  }
<% end %>